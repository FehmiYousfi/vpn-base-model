// UOrb control mechanism for OpenVPN client

#include <uORB/topics/openvpn_control.h>
#include <uORB/topics/openvpn_status.h>

// Control states
enum class VpnControlState {
    INIT,
    CONNECTING,
    CONNECTED, 
    DISCONNECTING,
    DISCONNECTED,
    ERROR
};

class VpnController {
public:
    VpnController() {
        // Initialize uORB topics
        _control_sub = orb_subscribe(ORB_ID(openvpn_control));
        _status_pub = orb_advertise(ORB_ID(openvpn_status), &_status);
        
        _status.state = static_cast<uint8_t>(VpnControlState::INIT);
        _status.timestamp = hrt_absolute_time();
    }

    ~VpnController() {
        orb_unsubscribe(_control_sub);
    }

    void update() {
        // Check for new control messages
        bool updated = false;
        orb_check(_control_sub, &updated);

        if (updated) {
            struct openvpn_control_s control;
            orb_copy(ORB_ID(openvpn_control), _control_sub, &control);

            handle_control_msg(control);
        }

        // Update status
        _status.timestamp = hrt_absolute_time();
        orb_publish(ORB_ID(openvpn_status), _status_pub, &_status);
    }

private:
    void handle_control_msg(const openvpn_control_s& control) {
        switch (control.cmd) {
            case OPENVPN_CMD_START:
                if (_status.state == static_cast<uint8_t>(VpnControlState::DISCONNECTED)) {
                    _status.state = static_cast<uint8_t>(VpnControlState::CONNECTING);
                    // Signal main thread to start VPN
                }
                break;

            case OPENVPN_CMD_STOP:
                if (_status.state == static_cast<uint8_t>(VpnControlState::CONNECTED)) {
                    _status.state = static_cast<uint8_t>(VpnControlState::DISCONNECTING);
                    // Signal main thread to stop VPN
                }
                break;

            default:
                break;
        }
    }

    int _control_sub;
    orb_advert_t _status_pub;
    struct openvpn_status_s _status;
};

// Global controller instance
static VpnController* g_vpn_controller = nullptr;



#include <px4_platform_common/tasks.h>
#include <px4_platform_common/posix.h>
#include <unistd.h>

static int vpn_control_task(int argc, char *argv[])
{
    g_vpn_controller = new VpnController();

    while (!px4_should_exit()) {
        g_vpn_controller->update();
        px4_usleep(10000); // 10ms sleep
    }

    delete g_vpn_controller;
    g_vpn_controller = nullptr;
    
    return 0;
}

static int vpn_toggle_task(int argc, char *argv[]) 
{
    struct openvpn_control_s control {};
    orb_advert_t control_pub = orb_advertise(ORB_ID(openvpn_control), &control);

    bool vpn_enabled = false;

    while (!px4_should_exit()) {
        // Toggle VPN state every 5 seconds
        control.cmd = vpn_enabled ? OPENVPN_CMD_STOP : OPENVPN_CMD_START;
        control.timestamp = hrt_absolute_time();
        orb_publish(ORB_ID(openvpn_control), control_pub, &control);

        vpn_enabled = !vpn_enabled;
        px4_sleep(5);
    }

    orb_unadvertise(control_pub);
    return 0;
}

extern "C" __EXPORT int openvpn_main(int argc, char *argv[])
{
    // Start VPN controller task
    int vpn_task = px4_task_spawn_cmd("vpn_control",
                                     SCHED_DEFAULT,
                                     SCHED_PRIORITY_DEFAULT,
                                     2048,
                                     vpn_control_task,
                                     nullptr);

    // Start VPN toggle task                                 
    int toggle_task = px4_task_spawn_cmd("vpn_toggle",
                                        SCHED_DEFAULT,
                                        SCHED_PRIORITY_DEFAULT,
                                        2048,
                                        vpn_toggle_task,
                                        nullptr);

    return 0;
}

